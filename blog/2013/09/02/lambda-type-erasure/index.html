
<!DOCTYPE html>
<html lang="en">
  <head>
    

<meta charset="utf-8">
<title>lambda type erasure - tclamb</title>
<meta name="author" content="Thomas Lamb">
<meta name="description"
      content="lambda type erasure extracting call signature from lambda type
Thanks to ecatmur from stackoverflow for his work on this question. 1
2
3
4
5 &hellip;">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="canonical" href="http://tclamb.github.io/blog/2013/09/02/lambda-type-erasure">
<link href="/favicon.png" rel="icon">
<link href="http://fonts.googleapis.com/css?family=Droid+Serif|Raleway|Open+Sans"
      rel="stylesheet"
      type='text/css'>
<link href="/stylesheets/screen.css"
      media="screen, projection"
      rel="stylesheet"
      type="text/css">
<link href="/atom.xml"
      rel="alternate"
      title="tclamb"
      type="application/atom+xml">


<script src="http://code.jquery.com/jquery-1.10.2.min.js" type="text/javascript"></script>
<script src="/javascripts/modernizr-2.0.js" type="text/javascript"></script>
<script src="/javascripts/ender.js" type="text/javascript"></script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>


<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-43030634-1']);
  _gaq.push(['_trackPageview']);  
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') +
      '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


  </head>
  <body>
    <header role="banner" class="site_metas">
      
<hgroup>
  <h1><a href="/">tclamb</a></h1>
  
  <h2>programming, c++ and otherwise</h2>
  
</hgroup>

    </header>

    <hr>

    <div id="content">
	  

  


<article class="entry" role="article">

  <header>
    <h2 class="entry_title">lambda type erasure</h2>
    
  </header>

  <div class="entry_content"><h3 id="extracting-call-signature-from-lambda-type">extracting call signature from lambda type</h3>
<p>Thanks to <a href="http://stackoverflow.com/users/567292/ecatmur">ecatmur</a> from <a href="http://stackoverflow.com/">stackoverflow</a> for his work on <a href="http://stackoverflow.com/questions/11893141/inferring-the-call-signature-of-a-lambda-or-arbitrary-callable-for-make-functio">this question</a>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_class</span> <span class="p">{};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span><span class="o">&gt;</span>       <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span> <span class="p">};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span> <span class="k">const</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="lambda-as-a-function">lambda as a function</h3>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="n">function_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">remove_class</span><span class="o">&lt;</span>
</span><span class="line">    <span class="n">decltype</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="p">)</span>
</span><span class="line"><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="helper-function">helper function</h3>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class="line"><span class="n">function_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span> <span class="n">make_function</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">)};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="example-usage">example usage</h3>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="cm">/* identity function: decltype( f ) == std::function&lt;int(int)&gt; */</span>
</span><span class="line">    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">make_function</span><span class="p">([](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">});</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* zero function: decltype( make_function(g) ) == std::function&lt;int()&gt;</span>
</span><span class="line"><span class="cm">     * declared as mutable to test non-const R(C::*)(A...)</span>
</span><span class="line"><span class="cm">     * overload of remove_class</span>
</span><span class="line"><span class="cm">     * see 5.1.2:5 of standard for use of mutable with lambdas */</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* should return 0 */</span>
</span><span class="line">    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">make_function</span><span class="p">(</span><span class="n">g</span><span class="p">)();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="putting-it-all-together">putting it all together</h3>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="cp">#include &lt;functional&gt;</span>
</span><span class="line"><span class="cp">#include &lt;type_traits&gt;</span>
</span><span class="line"><span class="cp">#include &lt;utility&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">namespace</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="cm">/* SFNIAE helper struct for call signature extraction of</span>
</span><span class="line"><span class="cm">     * member functions */</span>
</span><span class="line">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_class</span> <span class="p">{};</span>
</span><span class="line">
</span><span class="line">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span><span class="o">&gt;</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span> <span class="k">const</span><span class="o">&gt;</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* lambda functions are never volatile (see 5.1.2:5 of the standard)</span>
</span><span class="line"><span class="cm">     * these specializations are provided for completeness */</span>
</span><span class="line">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span> <span class="k">volatile</span><span class="o">&gt;</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">remove_class</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="p">)(</span><span class="n">A</span><span class="p">...)</span> <span class="k">const</span> <span class="k">volatile</span><span class="o">&gt;</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">A</span><span class="p">...);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="n">function_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">remove_class</span><span class="o">&lt;</span>
</span><span class="line">    <span class="n">decltype</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">::</span><span class="k">operator</span><span class="p">()</span> <span class="p">)</span>
</span><span class="line"><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&gt;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
</span><span class="line"><span class="n">function_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span> <span class="n">make_function</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">functor</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">functor</span><span class="p">)};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

</div>

  <footer>
    <p class="meta">

      

      
      <time datetime="2013-09-02 17:31:00 -0400" pubdate>Sep 2<span>nd</span>, 2013</time>
      

      
      <span class="categories">
	
      </span>
      

    </p>

    

    

  </footer>
  
</div>

    </div>

    <hr>

    <footer role="contentinfo">
	  <p>
  &copy; 2013 - Thomas Lamb -
  <span class="credit">powered by <a href="http://octopress.org">octopress</a> and based on <a href="http://k-ui.jp">k-ui</a>'s <a href="https://github.com/kui/k-ui-octopress-theme">octopress theme</a></span>
</p>

    </footer>
      
    










  </body>
</html>
